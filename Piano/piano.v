/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_DCM_SP #(
    parameter integer CLKFX_DIVIDE = 1,
    parameter integer CLKFX_MULTIPLY = 2,
    parameter real CLKIN_PERIOD = 10.0
)
(
    input cin,
    output cout
);
    // DCM_SP: Digital Clock Manager
    // Spartan-6
    // Xilinx HDL Libraries Guide, version 14.1

    DCM_SP #(
        .CLKDV_DIVIDE(2.0),     // CLKDV divide value
                                // (1.5,2,2.5,3,3.5,4,4.5,5,5.5,6,6.5,7,7.5,8,9,10,11,12,13,14,15,16).
        .CLKFX_DIVIDE(CLKFX_DIVIDE),       // Divide value on CLKFX outputs - D - (1-32)
        .CLKFX_MULTIPLY(CLKFX_MULTIPLY),   // Multiply value on CLKFX outputs - M - (2-32)
        .CLKIN_DIVIDE_BY_2("FALSE"),       // CLKIN divide by two (TRUE/FALSE)
        .CLKIN_PERIOD(CLKIN_PERIOD),       // Input clock period specified in nS
        .CLKOUT_PHASE_SHIFT("NONE"), //Output phase shift (NONE, FIXED, VARIABLE)
        .CLK_FEEDBACK("1X"),         // Feedback source (NONE, 1X, 2X)
        .DESKEW_ADJUST("SYSTEM_SYNCHRONOUS"), // SYSTEM_SYNCHRNOUS or SOURCE_SYNCHRONOUS
        .DFS_FREQUENCY_MODE("LOW"), // Unsupported - Do not change value
        .DLL_FREQUENCY_MODE("LOW"), // Unsupported - Do not change value
        .DSS_MODE("NONE"), // Unsupported - Do not change value
        .DUTY_CYCLE_CORRECTION("TRUE"), // Unsupported - Do not change value
        .FACTORY_JF(16'hc080), // Unsupported - Do not change value
        .PHASE_SHIFT(0), // Amount of fixed phase shift (-255 to 255)
        .STARTUP_WAIT("FALSE") // Delay config DONE until DCM_SP LOCKED (TRUE/FALSE)
    )
    DCM_SP_inst (
        .CLK0(), // 1-bit output: 0 degree clock output
        .CLK180(), // 1-bit output: 180 degree clock output
        .CLK270(), // 1-bit output: 270 degree clock output
        .CLK2X(), // 1-bit output: 2X clock frequency clock output
        .CLK2X180(), // 1-bit output: 2X clock frequency, 180 degree clock output
        .CLK90(), // 1-bit output: 90 degree clock output
        .CLKDV(), // 1-bit output: Divided clock output
        .CLKFX(cout), // 1-bit output: Digital Frequency Synthesizer output (DFS)
        .CLKFX180(), // 1-bit output: 180 degree CLKFX output
        .LOCKED(), // 1-bit output: DCM_SP Lock Output
        .PSDONE(), // 1-bit output: Phase shift done output
        .STATUS(), // 8-bit output: DCM_SP status output
        .CLKFB(), // 1-bit input: Clock feedback input
        .CLKIN(cin), // 1-bit input: Clock input
        .DSSEN(1'b0), // 1-bit input: Unsupported, specify to GND.
        .PSCLK(1'b0), // 1-bit input: Phase shift clock input
        .PSEN(1'b0), // 1-bit input: Phase shift enable
        .PSINCDEC(), // 1-bit input: Phase shift increment/decrement input
        .RST(1'b0) // 1-bit input: Active high reset input
    );
endmodule

module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module DIG_ROM_32X4 (
    input [4:0] A,
    input sel,
    output reg [3:0] D
);
    reg [3:0] my_rom [0:31];

    always @ (*) begin
        if (~sel)
            D = 4'hz;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 4'h8;
        my_rom[1] = 4'h9;
        my_rom[2] = 4'ha;
        my_rom[3] = 4'hc;
        my_rom[4] = 4'hd;
        my_rom[5] = 4'he;
        my_rom[6] = 4'hf;
        my_rom[7] = 4'hf;
        my_rom[8] = 4'hf;
        my_rom[9] = 4'hf;
        my_rom[10] = 4'he;
        my_rom[11] = 4'hd;
        my_rom[12] = 4'hc;
        my_rom[13] = 4'hb;
        my_rom[14] = 4'ha;
        my_rom[15] = 4'h8;
        my_rom[16] = 4'h7;
        my_rom[17] = 4'h5;
        my_rom[18] = 4'h4;
        my_rom[19] = 4'h3;
        my_rom[20] = 4'h2;
        my_rom[21] = 4'h1;
        my_rom[22] = 4'h0;
        my_rom[23] = 4'h0;
        my_rom[24] = 4'h0;
        my_rom[25] = 4'h0;
        my_rom[26] = 4'h1;
        my_rom[27] = 4'h2;
        my_rom[28] = 4'h3;
        my_rom[29] = 4'h5;
        my_rom[30] = 4'h6;
        my_rom[31] = 4'h8;
    end
endmodule


module piano (
  input bntDo,
  input btnRe,
  input btnMi,
  input btnFa,
  input CLK,
  output [3:0] Sonido
);
  wire s0;
  wire HzDo;
  wire [26:0] s1;
  wire [26:0] s2;
  wire HzRe;
  wire [26:0] s3;
  wire HzMI;
  wire [26:0] s4;
  wire HzFa;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire [4:0] s10;
  DIG_DCM_SP #(
    .CLKFX_DIVIDE(2),
    .CLKFX_MULTIPLY(2),
    .CLKIN_PERIOD(10.0)
  )
  DIG_DCM_SP_i0 (
    .cin( CLK ),
    .cout( s0 )
  );
  DIG_Counter_Nbit #(
    .Bits(27)
  )
  DIG_Counter_Nbit_i1 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( HzDo ),
    .out( s1 )
  );
  DIG_Counter_Nbit #(
    .Bits(27)
  )
  DIG_Counter_Nbit_i2 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( HzDo ),
    .out( s2 )
  );
  DIG_Counter_Nbit #(
    .Bits(27)
  )
  DIG_Counter_Nbit_i3 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( HzDo ),
    .out( s3 )
  );
  DIG_Counter_Nbit #(
    .Bits(27)
  )
  DIG_Counter_Nbit_i4 (
    .en( 1'b1 ),
    .C( s0 ),
    .clr( HzDo ),
    .out( s4 )
  );
  Mux_2x1 Mux_2x1_i5 (
    .sel( bntDo ),
    .in_0( 1'b0 ),
    .in_1( HzDo ),
    .out( s5 )
  );
  Mux_2x1 Mux_2x1_i6 (
    .sel( bntDo ),
    .in_0( 1'b0 ),
    .in_1( HzDo ),
    .out( s6 )
  );
  Mux_2x1 Mux_2x1_i7 (
    .sel( bntDo ),
    .in_0( 1'b0 ),
    .in_1( HzDo ),
    .out( s7 )
  );
  Mux_2x1 Mux_2x1_i8 (
    .sel( bntDo ),
    .in_0( 1'b0 ),
    .in_1( HzDo ),
    .out( s8 )
  );
  CompUnsigned #(
    .Bits(27)
  )
  CompUnsigned_i9 (
    .a( 27'b1111111101111110011 ),
    .b( s1 ),
    .\= ( HzDo )
  );
  CompUnsigned #(
    .Bits(27)
  )
  CompUnsigned_i10 (
    .a( 27'b10001111011001000010 ),
    .b( s2 ),
    .\= ( HzRe )
  );
  CompUnsigned #(
    .Bits(27)
  )
  CompUnsigned_i11 (
    .a( 27'b10100000111100110111 ),
    .b( s3 ),
    .\= ( HzMI )
  );
  CompUnsigned #(
    .Bits(27)
  )
  CompUnsigned_i12 (
    .a( 27'b10101010100001011000 ),
    .b( s4 ),
    .\= ( HzFa )
  );
  assign s9 = (s5 | s6 | s7 | s8);
  DIG_Counter_Nbit #(
    .Bits(5)
  )
  DIG_Counter_Nbit_i13 (
    .en( 1'b1 ),
    .C( s9 ),
    .clr( 1'b0 ),
    .out( s10 )
  );
  DIG_ROM_32X4 DIG_ROM_32X4_i14 (
    .A( s10 ),
    .sel( 1'b1 ),
    .D( Sonido )
  );
endmodule
